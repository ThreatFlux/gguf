rd_("Ad8-bit signed integer00000AbI/O error occurred0AjContains the success value0Af8-bit unsigned integer000AhContains the error value0Ae16-bit floating point0Ae32-bit floating point00000Ae64-bit floating point00000Ae16-bit signed integer00000Ae32-bit signed integer00000Ae64-bit signed integer00000Ag16-bit unsigned integer000Ag32-bit unsigned integer000Ag64-bit unsigned integer000AfAdd any metadata value0AhGet a specific dimension0AgGet an element by indexAbGet a value by keyAdGet a metadata value210AkGet the length of the arrayBaGet the number of key-value pairsAdGet the current sizeA`Get tensor countAiGet the number of entriesBjGet the length of the tensor data in bytes543210AbFP16 minimum value000CiCreate alignment information for a given position and \xe2\x80\xa6AnCreate a new alignment trackerAkCreate a new metadata arrayBfCreate a new empty metadata collectionBlCreate a new GGUF header with default valuesAhCreate a new tensor infoBfCreate a new memory-mapped GGUF readerAiCreate a new GGUF builderAmCreate a new metadata builderBfCreate a new tensor collection builderAiCreate new empty metadataChCreate a new GGUF file reader with default configurationCeCreate a new stream reader with default configurationAjCreate a new tensor readerBiCreate a new tensor shape from dimensions94ChCreate a new GGUF file writer with default configurationAnCreate a new streaming builderAjCreate a new stream writerAjCreate a new tensor writerCiCreate alignment information for a given position and \xe2\x80\xa6AnCreate a new alignment trackerAkCreate a new metadata arrayBfCreate a new empty metadata collectionBlCreate a new GGUF header with default valuesAhCreate a new tensor infoBfCreate a new memory-mapped GGUF readerAiCreate a new GGUF builderAmCreate a new metadata builderBfCreate a new tensor collection builderAiCreate new empty metadataChCreate a new GGUF file reader with default configurationCeCreate a new stream reader with default configurationAjCreate a new tensor readerBiCreate a new tensor shape from dimensions94ChCreate a new GGUF file writer with default configurationAnCreate a new streaming builderAjCreate a new stream writerAjCreate a new tensor writerAobfloat16 (Brain Floating Point)0mBoolean value000BfNo quantization (F32, F16, BF16, etc.)0Ai2-bit quantized (K-quant)0Ai3-bit quantized (K-quant)0Ao4-bit quantized (block size 32)0Bl4-bit quantized (block size 32, with scales)0Al4-bit quantized (superseded)000Ai4-bit quantized (K-quant)0Ao5-bit quantized (block size 32)0Bl5-bit quantized (block size 32, with scales)0Ai5-bit quantized (K-quant)0Ai6-bit quantized (K-quant)0o8-bit quantized0Am8-bit quantized (with scales)0Ai8-bit quantized (K-quant)0AhMetadata key-value pairsoThe tensor dataBbTensor data storage and managementB`Get the tensor data if availableBoActual tensor data (may be empty if not loaded)Ck16 bytes of 4-bit quantized values (32 values, 4 bits each)Bb16 bytes of 4-bit quantized values00Bb32 bytes of 8-bit quantized values0nQuantized data000BaQuantized data (6 bits per value)1BiCompressed data (implementation specific)00:9876544433222212000AmGet the dimensions as a slice0AoReturns the argument unchanged.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BjGGUF - A Rust library for GGUF file formatBjTensor information and metadata structures0BaCalls <code>U::from(self)</code>.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AgIterate over the valuesAlIterate over key-value pairs10lGet all keys0BeMemory mapping support for GGUF filesBkMemory-map a GGUF file for efficient accessnThe memory map210AbName of the tensorBfGet a human-readable name for the typeBnGet the human-readable name of the tensor typeAcHuman-readable nameAcGet the tensor name4kTensor name5432150AlGet the number of dimensions0BgSeek to a specific position in the file0AkSeek to a specific position01100BcGet the size of the header in bytes0AgTags for categorization0oArray of values000AhEmpty/uninitialized dataAcEmpty/uninitialized10Al4-bit quantized (IQ variant)0Al3-bit quantized (IQ variant)01111BdOwned byte vector (most common case)AgOwned in-memory storage10AeReady to write header0B`Async I/O support for GGUF files0AbBuild the metadataAkBuild the tensor collectionBfBuild and write the complete GGUF file210AhCreate empty tensor data0B`Error types for the GGUF library0A`Flush the writer000AlCheck if this is a 3D tensor0AlCheck if this is a 4D tensor0BjMagic number (\xe2\x80\x9cGGUF\xe2\x80\x9d in little-endian)0AaFP16 scale factor0000AaFP32 scale factor111110AhGet the shape as a sliceBcTensor shape and dimension handlingAdGet the tensor shapeAcShape of the tensor3210BaCreate a slice of the tensor data0AaGet current state0AoGGUF data types and type system0ChCreate tensor data with specified size filled with zeros0mCustom layout0lFormat error0Al2-bit quantized (IQ variant)0Al4-bit quantized (IQ variant)000B`IQ-quant schemes (ultra-low bit)0BcK-quant schemes (Q2_K through Q8_K)0CkLegacy GGML quantization (Q4_0, Q4_1, Q5_0, Q5_1, Q8_0, \xe2\x80\xa60BlMemory-mapped data (when using mmap feature)AjMemory-mapped file storage10BeResult type alias for GGUF operations0AmShared reference-counted dataB`Shared reference-counted storage10lUTF-8 string000BaTry to convert to a specific type0BjBlock-based quantization format structures0BdConcatenate with another tensor data0CkSimple little-endian byte operations to avoid byteorder \xe2\x80\xa60CjCreate tensor data with specified size filled with a value0BhGGUF format specification and structures0BjGGUF file header structures and operationsAcGet the file headerkFile header1021010AgInsert a key-value pairAdAdd a metadata entry10AbNumber of elementsAbLength of the data10AkCreate a matrix tensor (2D)0ChOffset of the tensor data from the start of the data \xe2\x80\xa6AeOffset within the map10AnGGUF file reader functionality0AgRemove a key-value pair0BgCreate a scalar tensor (1D with size 1)0AcScales and metadatafScales00010000BmCreate a simple GGUF file with basic metadata0C`Source information (where this tensor came from)0BoTensor data structures and quantization formats0nGet all valuesnArray elements10AkCreate a vector tensor (1D)0AnGGUF file writer functionality0Al4-bit quantized (IQ variant)0Al3-bit quantized (IQ variant)0Bi4-bit quantized (IQ variant, ultra-small)0mInteger types0oAdd a f32 value0iAdd a tag0oAdd a u32 value0oAdd a u64 value0BhAdvance the position by the given amount0CgHigh-level builder pattern APIs for creating GGUF files0AkKey-value pairs of metadata0AhFlatten the tensor to 1D0AgGet an f64 value by key0AgGet an i64 value by key0AfGet a u64 value by key0BjGGUF - A Rust library for GGUF file formatBkWhether this format supports minimum values0AkCheck if has a specific tag0AiCalculated padding needed0jRead an i80iRead a u80CmReshape the tensor to a new shape with the same number of \xe2\x80\xa60AkRemove dimensions of size 10AbStride information0BfCreate a summary of what will be builtAnGet a summary of the GGUF fileBiGet a summary of what we\xe2\x80\x99ve read so farAlGet a human-readable summary3210AlVersion number (currently 3)AcVersion information10CdReference to borrowed data (zero-copy when possible)AmBorrowed from external source10A`Writing complete0BfCollection of metadata key-value pairsBcMetadata collection for a GGUF file10AjRow-major (C-style) layout0AcAdd a boolean value0BjAlign a position to the specified boundaryCbAlign to specific boundary and return padding info10AnGet a slice of the tensor data0BbChecksum of the data (if computed)CjCalculate a simple checksum of the data (for integrity \xe2\x80\xa6BdData checksum for integrity checkingBfChecksum of written data (if computed)AdChecksum if computed43210AfCheck if tensor exists0BdGet mutable tensor data if available0BeGet the dimensions as a mutable slice0ChFinalize the file (flush and ensure all data is written)C`Finalize the stream (flush and mark as finished)10BlGet tensor type information for a given typeBmGet quantization parameters for a tensor type10BaConvert from u32 to GGUFValueTypeBbConvert from u32 to GGUFTensorType10AgGet a bool value by key0AnCheck if tensor data is loaded0AkCheck if the array is emptyAnCheck if the metadata is emptynCheck if empty00BaCheck if the tensor data is emptyAjCheck if metadata is empty4322210BdCheck if this type is floating point0CfCheck if the header has valid magic number and versionBaCheck if the tensor info is valid10B`Metadata handling for GGUF filesBgGGUF metadata structures and operationsA`Get the metadata0AfGet metadata referenceAcAdditional metadataAiScales and other metadata5433210BcCurrent position in the file/streamBeCurrent position in the output streamBdGet the current position in the fileAlGet current position in fileBbGet current position in the streamAdGet current position000543210000BcRead an f32 in little-endian format0BcRead an f64 in little-endian format0BcRead an i16 in little-endian format0BcRead an i32 in little-endian format0BcRead an i64 in little-endian format0BbRead a u16 in little-endian format0BbRead a u32 in little-endian formatBhRead a u32 value in little-endian format10BbRead a u64 in little-endian formatBhRead a u64 value in little-endian format10AcSet the tensor data0BlConvert to owned data (cloning if necessary)0BlWhether to use memory mapping when available0CbValidate the header and return an error if invalidAhValidate the tensor infoBjValidate the builder state before buildingBlValidate the stream data we\xe2\x80\x99ve read so farBnValidate the tensor data for basic consistencyBkValidate that the tensor info is consistent543210kWrite an i80BbWrite a metadata value to a writerBbWrite a metadata array to a writerAjWrite metadata to a writerAlWrite the header to a writerAmWrite tensor info to a writer43210jWrite a u80CgError types that can occur when working with GGUF files0BjQ2_K quantization block (256 2-bit values)0BjQ3_K quantization block (256 3-bit values)0CaQ4_0 quantization block (32 4-bit values + scale)0CgQ4_1 quantization block (32 4-bit values + scale + min)0BjQ4_K quantization block (256 4-bit values)0CaQ5_0 quantization block (32 5-bit values + scale)0CgQ5_1 quantization block (32 5-bit values + scale + min)0BjQ5_K quantization block (256 5-bit values)0BjQ6_K quantization block (256 6-bit values)0CaQ8_0 quantization block (32 8-bit values + scale)0CgQ8_1 quantization block (32 8-bit values + scale + sum)0BjQ8_K quantization block (256 8-bit values)0BgData alignment utilities for GGUF filesAkRequired alignment boundaryBkGet the alignment requirement for this typeBeGet the alignment of the data pointerBbAlignment boundary (if applicable)AfAlignment requirements543210AnGet all supported tensor types0BgGGUF format constants and magic numbers0BnCreate a GGUF file from an existing memory map0Bg4 bytes for high bits (1 bit per value)Ae4 bytes for high bitsAmHigh bits for extra precisioniHigh bits3210AfWhether data is loaded0BhWhether the memory is mapped from a file0AnCheck if this is a matrix (2D)0BjCheck if this is a scalar (single element)0AlWhether the memory is shared0AlCheck if this type is signed0BoCheck if this is a vector (1D with size &gt; 1)0mMaximum value0BfMinimum value (for numerical analysis)0AlCreate new owned tensor data0BcRead a metadata value from a readerBcRead a metadata array from a readerAkRead metadata from a readerAkRead a header from a readerAnRead tensor info from a reader43210BaTake ownership of the tensor data0AbCreate a 3D tensor0AbCreate a 4D tensor0C`Transpose the tensor (swap first two dimensions)0B`Whether validation was performed0AlCreate tensor info with data0BkCreate a tensor reader with seeking supportAhCreate a seekable writer10BdWrite an f32 in little-endian format0BdWrite an f64 in little-endian format0BdWrite an i16 in little-endian format0BdWrite an i32 in little-endian format0BdWrite an i64 in little-endian format0BcWrite a u16 in little-endian format0BcWrite a u32 in little-endian format0BcWrite a u64 in little-endian format0AjGGUF file header structure0ClMagic number for GGUF files (\xe2\x80\x9cGGUF\xe2\x80\x9d in little-endian \xe2\x80\xa60CiContainer for tensor data with different storage backends0BkInformation about a tensor in the GGUF fileBcComplete information about a tensor10AbAdd a string value0AfAdd a tensor with datalAdd a tensor0100AfCustom key-value pairs0BfGet the block size for quantized typesCdBlock size for quantized types (1 for non-quantized)CfBlock size (number of elements per quantization block)210AaActual bytes read0CdClear the tensor data (useful for memory management)0B`Shape of the tensor (dimensions)AhDimensions of the tensor10CbCalculate the memory efficiency (used / allocated)0AiGet a string value by key0BcWhether this format supports scales0AhCheck if a tensor exists0CdGet underlying reader (consuming the GGUFFileReader)CjConvert to underlying reader (consuming the stream reader)AiGet the underlying writer02100CgTake ownership of the data if possible, otherwise clone0ChCheck if a position is aligned to the specified boundaryBnCheck if currently aligned to default boundaryBeCheck if the data is properly alignedAkWhether the data is aligned3210AoCheck if this is a K-quant type0jMean value0B`Create memory-mapped tensor data0AmCreate new shared tensor data0BdAsync version of reading a GGUF file0BbRead bytes at the current position0lRemove a tag0jSet source0AiSize of the data in bytes0AhSkip bytes in the stream0AiTotal size of all tensors0AdUsed memory in bytes0BcGet the type of this metadata value0AgNumber of zero elements0BcColumn-major (Fortran-style) layout0BjHigh-level builder for creating GGUF files0AiIQ4_NL quantization block0B`Represents the shape of a tensor0BaSummary statistics about a tensor0BbInformation about what was written0AeInternal writer state0AkCreate a bias vector tensor0AgBuffer size for readingBbBuffer size for internal buffering1AgBuffer size for writingBcBuffer size for internal operationsAoBuffer size for chunked writing434210AcGet the data offsetBiOffset in the GGUF file where data begins10BeDescription of the tensor\xe2\x80\x99s purpose0AfFile-based GGUF reader0AfFile-based GGUF writer0kFine scales000AbSize of the header0CkGet a hexadecimal representation of the first few bytes \xe2\x80\xa60AlCheck if writing is complete0BaCheck if this is an IQ-quant type0BmCheck if this quantization format is lossless0BmCalculate the memory layout size with strides0CdCreate alignment information using default alignmentCjCreate a new alignment tracker with GGUF default alignment10kSet version0AgType of the tensor dataBeTensor type definitions and utilitiesoThe tensor typeAcGet the tensor typeAgData type of the tensorAoThe tensor type this applies to543210AhSet writer configurationCgCreate a new GGUF file reader with custom configurationCdCreate a new stream reader with custom configurationCgCreate a new GGUF file writer with custom configurationBmCreate a new stream writer with configuration43210AkCurrent GGUF format version0BmIQ2_XXS quantization block (ultra-compressed)0AjIQ3_XXS quantization block0AiInvalid GGUF magic number0AcMemory layout types0AgMemory-mapped GGUF file0AiTensor layout information0CkSpecialized reader for tensor data with format-specific \xe2\x80\xa60BbSpecialized writer for tensor data0AkAdd metadata key-value pairlAdd metadata10CeCalculate the aligned size for a given unaligned size0CdGet mutable access to the data (only for owned data)0AeCheck if a key exists0CmGet the size in bytes of a single element for this tensor \xe2\x80\xa60AmType of elements in the array0AlHigh-level GGUF file builder0BfCheck if this tensor type is quantizedAnWhether this type is quantized10AeActually loaded bytes0AkGet memory usage statisticsAlGet memory usage information0100AnGet mutable metadata reference0AdNumber of dimensions0AoCreate new borrowed tensor data0BlQuantization format structures and utilities0BhGet a string representation of the shape0AgGet storage information0AdGet the storage typelStorage type10AmNumber of tensors in the fileAiGet the number of tensorsAaNumber of tensors1AgTotal number of tensors200AoGet the number of tensors added432313110AfGet tensor information000A`Get tensor namesAdList of tensor namesAdGet all tensor namesAiGet tensor names in order3210AiCount of each tensor type00000BbCreate metadata for a vision model0AeWrite the GGUF headerA`Write the header10BlWrite tensor data with default configuration0BhAlignment information for a data section0AjAsync GGUF file operations0CiType identifiers used in the GGUF format for metadata \xe2\x80\xa60BbHeader written, ready for metadata0CbAn array of metadata values (all of the same type)0AoA metadata value in a GGUF file0AfUnexpected end of file0A`Add an attribute0CaAlign to default boundary and return padding info0AnBuild and write to a file path0AgNumber of bytes writtenAoBytes written in this operationmBytes written210AaClear all tensors0BnCalculate the number of elements in the tensorBfCalculate the total number of elements1101AfGet an attribute value0BkWhether this format has high-bit extensions0AhResult of writing headerAcHeader write result10BoCheck if currently aligned to specific boundaryCcCheck if the data is aligned to a specific boundary10CkCheck if this tensor is contiguous (for certain operations)BjWhether the tensor is contiguous in memory10BdCheck if a tensor type is deprecated0BkCheck if memory requirements are reasonable0BhMaximum file size to read (0 = no limit)0BmMemory layout (row-major, column-major, etc.)0AlSize of the metadata sectionAeGet the metadata size10AjCheck if padding is needed0CaCreate a tensor shape without validation (unsafe)0BiGet the padding as a vector of zero bytes0AgRemove a tensor by name0BjGet the size in bytes for fixed-size types0AbStandard deviation0CaStream-based GGUF reader for non-seekable streams0CaStream-based GGUF writer for non-seekable streams0BaTensor-specific reading utilities0BiSpecialized tensor data writing utilities0BgWhether to validate data before writing0BnWhether to validate tensor data before writing110AnWhether the data was validatedAjWhether data was validated10AmCreate a weight matrix tensor0AgA reader for GGUF files0AgA writer for GGUF files0BnType identifiers for tensor data types in GGUF0BnMemory-mapped GGUF reader for streaming access0BeInformation about tensor data storage0BaIterator over tensors in a stream0BaMetadata associated with a tensor0BjHelper for creating common tensor patterns0CiExtended tensor type information with additional metadata0AcWriting tensor data0AjAdd a tensor with F32 data0AjAdd a tensor with I32 data0CdAdd a vocabulary tensor (common for language models)0BkCheck if we\xe2\x80\x99re at the tensor data section0CbCalculate the broadcasted shape with another shape0AiBuild and return as bytes0CjCalculate the size in bytes for a given number of elements0AbClear all metadata0ChCheck if two tensor data instances have the same content0BgUtility to create padding bytes (zeros)0AfExpected size in bytes0AjFinal position in the fileAfFinal position in filenFinal position210C`Find the best tensor type for given requirements0B`Check if header has been written0BjCreate a GGUF builder for a language modelBdCreate metadata for a language model10CbGet the theoretical memory savings compared to F320BbGet the number of metadata entriesAjNumber of metadata entries001000CdConvenience function to open a GGUF file from a path0BdGet total overhead (non-tensor data)AeGet overhead in bytesBdGet overhead bytes (non-tensor data)AbGet overhead bytes3210BhGet compression ratio (overhead / total)0AdPosition after write0AfReset position counter0AhTensor builder utilities0AnResults of writing tensor dataAiTensor data write results10CbAdd a dimension at the end (unsqueeze at last dim)0nWrite metadata000BeSummary information about a GGUF file0BhMemory usage information for a GGUF file0BfResult of writing a complete GGUF file0A`Invalid metadata0AiBuilder for GGUF metadata0BgMetadata written, ready for tensor info0BoAligned for tensor data, ready to write tensors0BdUtility functions for tensor reading0BoUtility functions for working with tensor types0AjAdd tensor with TensorData0AiAllocated memory in bytes0CaBits per weight (approximate for quantized types)oBits per weight10AkBuild and write to a writer0CkCalculate basic statistics if data is available and numeric0B`Compare two quantization formats0CeGet the recommended replacement for a deprecated type0BbGet a specific tensor info by name000BbCheck if all tensor data is loaded0BjMaximum tensor size to read (0 = no limit)AjSize of the largest tensor10AjResult of writing metadataAeMetadata write result10CnGet the next power of 2 greater than or equal to the given \xe2\x80\xa60AnGet all quantized tensor types0C`Read a GGUF file from a file path asynchronously0BkCalculate the serialized size of this valueBkCalculate the serialized size of this arrayBmCalculate the serialized size of all metadataCkCalculate the minimum size needed to store this tensor info3210oSet description0BhCreate a streaming iterator over tensors0CeAdd a dimension at the beginning (unsqueeze at dim 0)0AfEnable data validation0ChHelper struct for tracking alignment during file writing0BcConfiguration for GGUF file reading0CaA reader for GGUF files from non-seekable streams0BoA writer for GGUF files to non-seekable streams0BcConfiguration for GGUF file writing0CgSize of the GGUF header in bytes (magic + version + \xe2\x80\xa60BeMemory usage information for a tensor0AmResult of reading tensor data0CgAlign a position to the default GGUF alignment boundary0AfFinal aligned position0AkResult of alignment paddingAfAlignment write result10AkSize of each block in bytes0BcCalculate tensor layout information0CdConvenience function to create a GGUF file at a path0AjCurrent position in streamAlCurrent position after write10AjCreate an embedding matrix0BcCheck if this type is variable-size0AhLoad tensor data by name0BhMaximum number of tensors to prevent DoS0AjMetadata builder utilities0B`Read all tensors in stream order0BmRead the next tensor\xe2\x80\x99s data in stream order0BeRead tensor data with default options0BmAlignment for tensor data (default: 32 bytes)AeTensor data alignment10AkSize of tensor info section0BaWhether the data was decompressed0AcInvalid tensor data0BgUtilities for working with quantization0BbResult of a stream write operation0BhTensor info written, ready for alignment0BhMemory usage information for tensor data0AjOptions for tensor reading0AgTypes of tensor storage0B`Configuration for tensor writing0AmResult of writing tensor data0AeGet alignment tracker0CjCalculate the padding needed to align to the specified \xe2\x80\xa6BnCalculate padding needed for default alignment10CbCalculate strides for C-style (row-major) ordering0AlWhether to compress metadata0BiGet compression ratio (loaded / expected)BiGet the compression ratio compared to F32BcCompression ratio (actual/expected)210BfWhether to compute and store checksumsAlWhether to compute checksums10AhDefault alignment to use0AjCheck if in tensor section0BdMaximum metadata size to prevent DoS0BbNumber of metadata key-value pairs0BcGet total tensor data bytes writtenAkGet total tensor data bytes10B`Calculate total tensor data sizeAiTotal size of tensor dataAmTotal size of all tensor data02100AlGet tensor types by category0AkAdd common LLaMA parameters0AaWrite tensor dataBkWrite tensor data (must be called in order)10CjOperation requires allocation but alloc feature is not \xe2\x80\xa60AeFeature not available0BiSummary of what a GGUFBuilder will create0BjMinimum valid GGUF file size (header only)0CbQuantization parameters for different tensor types0B`Configuration for stream reading0B`Configuration for stream writing0AhUnsupported GGUF version0CgGet the theoretical dynamic range for this quantization0BgWhether to load tensor data immediately0CgCalculate the expected size of the tensor data in bytes0CfCheck if a position is aligned to the default boundary0CgCheck if this tensor is compatible with another for \xe2\x80\xa60CaCheck if an alignment value is valid (power of 2)0AnGet tensor data section offsetAoOffset where tensor data begins10AmResult of writing tensor infoAhTensor info write result10BkGet total size including loaded tensor data0BbWhether to validate data alignment0AmWhether to validate checksums0BgValidate the integrity of the GGUF fileBbWhether to validate data integrityBhWhether to perform data integrity checks210B`Write tensor information sectionAhWrite tensor information10BbSummary of stream reading progress0BdGet all supported quantization types0AkGet the average tensor size0CgCheck if this tensor type is optimized for memory usage0AhNumber of loaded tensors0CgGet the shape for matrix multiplication (if applicable)0BbGet all non-quantized tensor types0CbCalculate optimal buffer size for reading a tensor0BlRead tensor data in chunks for large tensors0BnRead tensor data at a specific offset and size0BjCheck if a tensor should be read in chunks0AcTotal bytes written000AjWrite a complete GGUF file0BbCategories of quantization schemes0BcUtility for streaming GGUF creation0BnAdd a quantized tensor with raw quantized data0AlAdd a tensor with TensorData0CbCalculate the aligned size using default alignment0CmCalculate the number of blocks needed for a given element \xe2\x80\xa60BdWhether to decompress quantized data0AdLoad all tensor data0BjGet tensor types suitable for a model size0AkWrite tensor data in chunks0BjMaximum supported array length in metadata0AoAdd an output projection tensor0AlAlign to tensor data sectionAmAlign for tensor data section10BoCalculate padding needed for specific alignment0BeCheck if two shapes are broadcastable0BkLoad only specific tensors by name patterns0AhCategory of quantization0BaRead multiple tensors efficiently0BeRead tensor data at a specific offset0BoUpdate tensor offsets after writing tensor info0AdSet tensor alignment0BdWrite a complete GGUF file to stream0ChDefault alignment requirement for tensor data (32 bytes)0BkMaximum supported string length in metadata0CgConvenience function to create a buffered stream reader0CiCalculate the storage size for a given number of elements0BlGet current alignment info without advancing0BnCheck if a quantization type is considered \xe2\x80\xa60AkNumber of quantized tensors0CaRead multiple tensors by seeking to their offsets0CkGet recommended quantization for model size and quality \xe2\x80\xa60BeUnload all tensor data to save memory0CmPerform comprehensive validation including reasonableness \xe2\x80\xa60BbWrite multiple tensors in sequence0AnBuilder for tensor collections0CiGet the total size of header + metadata + tensor info \xe2\x80\xa60CbGet quantization family (legacy, k-quant, i-quant)0BcRecommended buffer size for reading0CkConvenience function to create a stream reader from any \xe2\x80\xa60CfCheck if this tensor type supports specific operations0BgMemory requirements for reading tensors0BnConvert to a string representation for display0BhWrite tensor data at a specific position0BkWrite tensor data with custom configuration0BhResult of writing a complete GGUF stream0CbCalculate the padding needed for default alignment0CfGet the most similar quantization to a target bit rate0CfCheck if this shape is compatible for element-wise \xe2\x80\xa60B`Actually loaded tensor data size0CgValidate that the shape is reasonable for practical use0BoWrite tensor data in chunks (for large tensors)0CgCheck if the tensor count is reasonable (not too large)0AoNumber of non-quantized tensors0ChConvenience function to open a GGUF file with custom \xe2\x80\xa60ChCheck if this type is suitable for a given precision \xe2\x80\xa60CaEstimate the quantization error (higher is worse)0AoExpected total tensor data size0CjConvenience function to create a GGUF file with custom \xe2\x80\xa60CiCheck if the metadata count is reasonable (not too large)0CaCalculate memory requirements for reading tensors0BdRead tensor data with custom options0")