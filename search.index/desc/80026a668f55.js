rd_("Ad8-bit signed integer00AbI/O error occurredAjContains the success valueAf8-bit unsigned integer0AhContains the error valueAe16-bit floating pointAe32-bit floating point00Ae64-bit floating point00Ae16-bit signed integer00Ae32-bit signed integer00Ae64-bit signed integer00Ag16-bit unsigned integer0Ag32-bit unsigned integer0Ag64-bit unsigned integer0AfAdd any metadata valueAhGet a specific dimensionAgGet an element by indexAbGet a value by keyAdGet a metadata valueAkGet the length of the arrayBaGet the number of key-value pairsAdGet the current sizeA`Get tensor countAiGet the number of entriesBjGet the length of the tensor data in bytesAbFP16 minimum value0CiCreate alignment information for a given position and \xe2\x80\xa6AnCreate a new alignment trackerAkCreate a new metadata arrayBfCreate a new empty metadata collectionBlCreate a new GGUF header with default valuesAhCreate a new tensor infoBfCreate a new memory-mapped GGUF readerAiCreate a new GGUF builderAmCreate a new metadata builderBfCreate a new tensor collection builderAiCreate new empty metadataChCreate a new GGUF file reader with default configurationCeCreate a new stream reader with default configurationAjCreate a new tensor readerBiCreate a new tensor shape from dimensions94ChCreate a new GGUF file writer with default configurationAnCreate a new streaming builderAjCreate a new stream writerAjCreate a new tensor writerAobfloat16 (Brain Floating Point)mBoolean value0BfNo quantization (F32, F16, BF16, etc.)Ai2-bit quantized (K-quant)Ai3-bit quantized (K-quant)Ao4-bit quantized (block size 32)Bl4-bit quantized (block size 32, with scales)Al4-bit quantized (superseded)0Ai4-bit quantized (K-quant)Ao5-bit quantized (block size 32)Bl5-bit quantized (block size 32, with scales)Ai5-bit quantized (K-quant)Ai6-bit quantized (K-quant)o8-bit quantizedAm8-bit quantized (with scales)Ai8-bit quantized (K-quant)AhMetadata key-value pairsoThe tensor dataBbTensor data storage and managementB`Get the tensor data if availableBoActual tensor data (may be empty if not loaded)Ck16 bytes of 4-bit quantized values (32 values, 4 bits each)Bb16 bytes of 4-bit quantized values00Bb32 bytes of 8-bit quantized values0nQuantized data000BaQuantized data (6 bits per value)1BiCompressed data (implementation specific)00AmGet the dimensions as a sliceAoReturns the argument unchanged.000000000000000000000000000000000000000000000000000000000000000000000000000BjGGUF - A Rust library for GGUF file formatBjTensor information and metadata structuresBaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000000000000000000AgIterate over the valuesAlIterate over key-value pairslGet all keysBeMemory mapping support for GGUF filesBkMemory-map a GGUF file for efficient accessnThe memory mapAbName of the tensorBfGet a human-readable name for the typeBnGet the human-readable name of the tensor typeAcHuman-readable nameAcGet the tensor name4kTensor nameAlGet the number of dimensionsBgSeek to a specific position in the file0AkSeek to a specific position0BcGet the size of the header in bytesAgTags for categorizationoArray of values0AhEmpty/uninitialized dataAcEmpty/uninitializedAl4-bit quantized (IQ variant)Al3-bit quantized (IQ variant)11BdOwned byte vector (most common case)AgOwned in-memory storageAeReady to write headerB`Async I/O support for GGUF filesAbBuild the metadataAkBuild the tensor collectionBfBuild and write the complete GGUF fileAhCreate empty tensor dataB`Error types for the GGUF libraryA`Flush the writer0AlCheck if this is a 3D tensorAlCheck if this is a 4D tensorBjMagic number (\xe2\x80\x9cGGUF\xe2\x80\x9d in little-endian)AaFP16 scale factor0000AaFP32 scale factorAhGet the shape as a sliceBcTensor shape and dimension handlingAdGet the tensor shapeAcShape of the tensorBaCreate a slice of the tensor dataAaGet current stateAoGGUF data types and type systemChCreate tensor data with specified size filled with zerosmCustom layoutlFormat errorAl2-bit quantized (IQ variant)Al4-bit quantized (IQ variant)0B`IQ-quant schemes (ultra-low bit)BcK-quant schemes (Q2_K through Q8_K)CkLegacy GGML quantization (Q4_0, Q4_1, Q5_0, Q5_1, Q8_0, \xe2\x80\xa6BlMemory-mapped data (when using mmap feature)AjMemory-mapped file storageBeResult type alias for GGUF operationsAmShared reference-counted dataB`Shared reference-counted storagelUTF-8 string0BaTry to convert to a specific typeBjBlock-based quantization format structuresBdConcatenate with another tensor dataCkSimple little-endian byte operations to avoid byteorder \xe2\x80\xa6CjCreate tensor data with specified size filled with a valueBhGGUF format specification and structuresBjGGUF file header structures and operationsAcGet the file headerkFile header10AgInsert a key-value pairAdAdd a metadata entryAbNumber of elementsAbLength of the dataAkCreate a matrix tensor (2D)ChOffset of the tensor data from the start of the data \xe2\x80\xa6AeOffset within the mapAnGGUF file reader functionalityAgRemove a key-value pairBgCreate a scalar tensor (1D with size 1)AcScales and metadatafScales000BmCreate a simple GGUF file with basic metadataC`Source information (where this tensor came from)BoTensor data structures and quantization formatsnGet all valuesnArray elementsAkCreate a vector tensor (1D)AnGGUF file writer functionalityAl4-bit quantized (IQ variant)Al3-bit quantized (IQ variant)Bi4-bit quantized (IQ variant, ultra-small)mInteger typesoAdd a f32 valueiAdd a tagoAdd a u32 valueoAdd a u64 valueBhAdvance the position by the given amountCgHigh-level builder pattern APIs for creating GGUF filesAkKey-value pairs of metadataAhFlatten the tensor to 1DAgGet an f64 value by keyAgGet an i64 value by keyAfGet a u64 value by keyBkWhether this format supports minimum valuesAkCheck if has a specific tagAiCalculated padding neededjRead an i8iRead a u8CmReshape the tensor to a new shape with the same number of \xe2\x80\xa6AkRemove dimensions of size 1AbStride informationBfCreate a summary of what will be builtAnGet a summary of the GGUF fileBiGet a summary of what we\xe2\x80\x99ve read so farAlGet a human-readable summaryAlVersion number (currently 3)AcVersion informationCdReference to borrowed data (zero-copy when possible)AmBorrowed from external sourceA`Writing completeBfCollection of metadata key-value pairsBcMetadata collection for a GGUF fileAjRow-major (C-style) layoutAcAdd a boolean valueBjAlign a position to the specified boundaryCbAlign to specific boundary and return padding infoAnGet a slice of the tensor dataBbChecksum of the data (if computed)CjCalculate a simple checksum of the data (for integrity \xe2\x80\xa6BdData checksum for integrity checkingBfChecksum of written data (if computed)AdChecksum if computedAfCheck if tensor existsBdGet mutable tensor data if availableBeGet the dimensions as a mutable sliceChFinalize the file (flush and ensure all data is written)C`Finalize the stream (flush and mark as finished)BlGet tensor type information for a given typeBmGet quantization parameters for a tensor typeBaConvert from u32 to GGUFValueTypeBbConvert from u32 to GGUFTensorTypeAgGet a bool value by keyAnCheck if tensor data is loadedAkCheck if the array is emptyAnCheck if the metadata is emptynCheck if empty00BaCheck if the tensor data is emptyAjCheck if metadata is emptyBdCheck if this type is floating pointCfCheck if the header has valid magic number and versionBaCheck if the tensor info is validB`Metadata handling for GGUF filesBgGGUF metadata structures and operationsA`Get the metadata0AfGet metadata referenceAcAdditional metadataAiScales and other metadataBcCurrent position in the file/streamBeCurrent position in the output streamBdGet the current position in the fileAlGet current position in fileBbGet current position in the streamAdGet current position000BcRead an f32 in little-endian formatBcRead an f64 in little-endian formatBcRead an i16 in little-endian formatBcRead an i32 in little-endian formatBcRead an i64 in little-endian formatBbRead a u16 in little-endian formatBbRead a u32 in little-endian formatBhRead a u32 value in little-endian formatBbRead a u64 in little-endian formatBhRead a u64 value in little-endian formatAcSet the tensor dataBlConvert to owned data (cloning if necessary)BlWhether to use memory mapping when availableCbValidate the header and return an error if invalidAhValidate the tensor infoBjValidate the builder state before buildingBlValidate the stream data we\xe2\x80\x99ve read so farBnValidate the tensor data for basic consistencyBkValidate that the tensor info is consistentkWrite an i8BbWrite a metadata value to a writerBbWrite a metadata array to a writerAjWrite metadata to a writerAlWrite the header to a writerAmWrite tensor info to a writerjWrite a u8CgError types that can occur when working with GGUF filesBjQ2_K quantization block (256 2-bit values)BjQ3_K quantization block (256 3-bit values)CaQ4_0 quantization block (32 4-bit values + scale)CgQ4_1 quantization block (32 4-bit values + scale + min)BjQ4_K quantization block (256 4-bit values)CaQ5_0 quantization block (32 5-bit values + scale)CgQ5_1 quantization block (32 5-bit values + scale + min)BjQ5_K quantization block (256 5-bit values)BjQ6_K quantization block (256 6-bit values)CaQ8_0 quantization block (32 8-bit values + scale)CgQ8_1 quantization block (32 8-bit values + scale + sum)BjQ8_K quantization block (256 8-bit values)BgData alignment utilities for GGUF filesAkRequired alignment boundaryBkGet the alignment requirement for this typeBeGet the alignment of the data pointerBbAlignment boundary (if applicable)AfAlignment requirementsAnGet all supported tensor typesBgGGUF format constants and magic numbersBnCreate a GGUF file from an existing memory mapBg4 bytes for high bits (1 bit per value)Ae4 bytes for high bitsAmHigh bits for extra precisioniHigh bitsAfWhether data is loadedBhWhether the memory is mapped from a fileAnCheck if this is a matrix (2D)BjCheck if this is a scalar (single element)AlWhether the memory is sharedAlCheck if this type is signedBoCheck if this is a vector (1D with size &gt; 1)mMaximum valueBfMinimum value (for numerical analysis)AlCreate new owned tensor dataBcRead a metadata value from a readerBcRead a metadata array from a readerAkRead metadata from a readerAkRead a header from a readerAnRead tensor info from a readerBaTake ownership of the tensor dataAbCreate a 3D tensorAbCreate a 4D tensorC`Transpose the tensor (swap first two dimensions)B`Whether validation was performedAlCreate tensor info with dataBkCreate a tensor reader with seeking supportAhCreate a seekable writerBdWrite an f32 in little-endian formatBdWrite an f64 in little-endian formatBdWrite an i16 in little-endian formatBdWrite an i32 in little-endian formatBdWrite an i64 in little-endian formatBcWrite a u16 in little-endian formatBcWrite a u32 in little-endian formatBcWrite a u64 in little-endian formatAjGGUF file header structureClMagic number for GGUF files (\xe2\x80\x9cGGUF\xe2\x80\x9d in little-endian \xe2\x80\xa6CiContainer for tensor data with different storage backendsBkInformation about a tensor in the GGUF fileBcComplete information about a tensorAbAdd a string valueAfAdd a tensor with datalAdd a tensor0AfCustom key-value pairsBfGet the block size for quantized typesCdBlock size for quantized types (1 for non-quantized)CfBlock size (number of elements per quantization block)AaActual bytes readCdClear the tensor data (useful for memory management)B`Shape of the tensor (dimensions)AhDimensions of the tensorCbCalculate the memory efficiency (used / allocated)AiGet a string value by keyBcWhether this format supports scalesAhCheck if a tensor existsCdGet underlying reader (consuming the GGUFFileReader)CjConvert to underlying reader (consuming the stream reader)AiGet the underlying writer0CgTake ownership of the data if possible, otherwise cloneChCheck if a position is aligned to the specified boundaryBnCheck if currently aligned to default boundaryBeCheck if the data is properly alignedAkWhether the data is alignedAoCheck if this is a K-quant typejMean valueB`Create memory-mapped tensor dataAmCreate new shared tensor dataBdAsync version of reading a GGUF fileBbRead bytes at the current positionlRemove a tagjSet sourceAiSize of the data in bytesAhSkip bytes in the streamAiTotal size of all tensorsAdUsed memory in bytesBcGet the type of this metadata valueAgNumber of zero elementsBcColumn-major (Fortran-style) layoutBjHigh-level builder for creating GGUF filesAiIQ4_NL quantization blockB`Represents the shape of a tensorBaSummary statistics about a tensorBbInformation about what was writtenAeInternal writer stateAkCreate a bias vector tensorAgBuffer size for readingBbBuffer size for internal buffering1AgBuffer size for writingBcBuffer size for internal operationsAoBuffer size for chunked writingAcGet the data offsetBiOffset in the GGUF file where data beginsBeDescription of the tensor\xe2\x80\x99s purposeAfFile-based GGUF readerAfFile-based GGUF writerkFine scales0AbSize of the headerCkGet a hexadecimal representation of the first few bytes \xe2\x80\xa6AlCheck if writing is completeBaCheck if this is an IQ-quant typeBmCheck if this quantization format is losslessBmCalculate the memory layout size with stridesCdCreate alignment information using default alignmentCjCreate a new alignment tracker with GGUF default alignmentkSet versionAgType of the tensor dataBeTensor type definitions and utilitiesoThe tensor typeAcGet the tensor typeAgData type of the tensorAoThe tensor type this applies toAhSet writer configurationCgCreate a new GGUF file reader with custom configurationCdCreate a new stream reader with custom configurationCgCreate a new GGUF file writer with custom configurationBmCreate a new stream writer with configurationAkCurrent GGUF format versionBmIQ2_XXS quantization block (ultra-compressed)AjIQ3_XXS quantization blockAiInvalid GGUF magic numberAcMemory layout typesAgMemory-mapped GGUF fileAiTensor layout informationCkSpecialized reader for tensor data with format-specific \xe2\x80\xa6BbSpecialized writer for tensor dataAkAdd metadata key-value pairlAdd metadataCeCalculate the aligned size for a given unaligned sizeCdGet mutable access to the data (only for owned data)AeCheck if a key existsCmGet the size in bytes of a single element for this tensor \xe2\x80\xa6AmType of elements in the arrayAlHigh-level GGUF file builderBfCheck if this tensor type is quantizedAnWhether this type is quantizedAeActually loaded bytesAkGet memory usage statisticsAlGet memory usage information0AnGet mutable metadata referenceAdNumber of dimensionsAoCreate new borrowed tensor dataBlQuantization format structures and utilitiesBhGet a string representation of the shapeAgGet storage informationAdGet the storage typelStorage typeAmNumber of tensors in the fileAiGet the number of tensorsAaNumber of tensors1AgTotal number of tensors200AoGet the number of tensors addedAfGet tensor information0A`Get tensor namesAdList of tensor namesAdGet all tensor namesAiGet tensor names in orderAiCount of each tensor type00BbCreate metadata for a vision modelAeWrite the GGUF headerA`Write the headerBlWrite tensor data with default configurationBhAlignment information for a data sectionAjAsync GGUF file operationsCiType identifiers used in the GGUF format for metadata \xe2\x80\xa6BbHeader written, ready for metadataCbAn array of metadata values (all of the same type)AoA metadata value in a GGUF fileAfUnexpected end of fileA`Add an attributeCaAlign to default boundary and return padding infoAnBuild and write to a file pathAgNumber of bytes writtenAoBytes written in this operationmBytes writtenAaClear all tensorsBnCalculate the number of elements in the tensorBfCalculate the total number of elements1AfGet an attribute valueBkWhether this format has high-bit extensionsAhResult of writing headerAcHeader write resultBoCheck if currently aligned to specific boundaryCcCheck if the data is aligned to a specific boundaryCkCheck if this tensor is contiguous (for certain operations)BjWhether the tensor is contiguous in memoryBdCheck if a tensor type is deprecatedBkCheck if memory requirements are reasonableBhMaximum file size to read (0 = no limit)BmMemory layout (row-major, column-major, etc.)AlSize of the metadata sectionAeGet the metadata sizeAjCheck if padding is neededCaCreate a tensor shape without validation (unsafe)BiGet the padding as a vector of zero bytesAgRemove a tensor by nameBjGet the size in bytes for fixed-size typesAbStandard deviationCaStream-based GGUF reader for non-seekable streamsCaStream-based GGUF writer for non-seekable streamsBaTensor-specific reading utilitiesBiSpecialized tensor data writing utilitiesBgWhether to validate data before writing0BnWhether to validate tensor data before writingAnWhether the data was validatedAjWhether data was validatedAmCreate a weight matrix tensorAgA reader for GGUF filesAgA writer for GGUF filesBnType identifiers for tensor data types in GGUFBnMemory-mapped GGUF reader for streaming accessBeInformation about tensor data storageBaIterator over tensors in a streamBaMetadata associated with a tensorBjHelper for creating common tensor patternsCiExtended tensor type information with additional metadataAcWriting tensor dataAjAdd a tensor with F32 dataAjAdd a tensor with I32 dataCdAdd a vocabulary tensor (common for language models)BkCheck if we\xe2\x80\x99re at the tensor data sectionCbCalculate the broadcasted shape with another shapeAiBuild and return as bytesCjCalculate the size in bytes for a given number of elementsAbClear all metadataChCheck if two tensor data instances have the same contentBgUtility to create padding bytes (zeros)AfExpected size in bytesAjFinal position in the fileAfFinal position in filenFinal positionC`Find the best tensor type for given requirementsB`Check if header has been writtenBjCreate a GGUF builder for a language modelBdCreate metadata for a language modelCbGet the theoretical memory savings compared to F32BbGet the number of metadata entriesAjNumber of metadata entries00CdConvenience function to open a GGUF file from a pathBdGet total overhead (non-tensor data)AeGet overhead in bytesBdGet overhead bytes (non-tensor data)AbGet overhead bytesBhGet compression ratio (overhead / total)AdPosition after writeAfReset position counterAhTensor builder utilitiesAnResults of writing tensor dataAiTensor data write resultsCbAdd a dimension at the end (unsqueeze at last dim)nWrite metadata0BeSummary information about a GGUF fileBhMemory usage information for a GGUF fileBfResult of writing a complete GGUF fileA`Invalid metadataAiBuilder for GGUF metadataBgMetadata written, ready for tensor infoBoAligned for tensor data, ready to write tensorsBdUtility functions for tensor readingBoUtility functions for working with tensor typesAjAdd tensor with TensorDataAiAllocated memory in bytesCaBits per weight (approximate for quantized types)oBits per weightAkBuild and write to a writerCkCalculate basic statistics if data is available and numericB`Compare two quantization formatsCeGet the recommended replacement for a deprecated typeBbGet a specific tensor info by name0BbCheck if all tensor data is loadedBjMaximum tensor size to read (0 = no limit)AjSize of the largest tensorAjResult of writing metadataAeMetadata write resultCnGet the next power of 2 greater than or equal to the given \xe2\x80\xa6AnGet all quantized tensor typesC`Read a GGUF file from a file path asynchronouslyBkCalculate the serialized size of this valueBkCalculate the serialized size of this arrayBmCalculate the serialized size of all metadataCkCalculate the minimum size needed to store this tensor infooSet descriptionBhCreate a streaming iterator over tensorsCeAdd a dimension at the beginning (unsqueeze at dim 0)AfEnable data validationChHelper struct for tracking alignment during file writingBcConfiguration for GGUF file readingCaA reader for GGUF files from non-seekable streamsBoA writer for GGUF files to non-seekable streamsBcConfiguration for GGUF file writingCgSize of the GGUF header in bytes (magic + version + \xe2\x80\xa6BeMemory usage information for a tensorAmResult of reading tensor dataCgAlign a position to the default GGUF alignment boundaryAfFinal aligned positionAkResult of alignment paddingAfAlignment write resultAkSize of each block in bytesBcCalculate tensor layout informationCdConvenience function to create a GGUF file at a pathAjCurrent position in streamAlCurrent position after writeAjCreate an embedding matrixBcCheck if this type is variable-sizeAhLoad tensor data by nameBhMaximum number of tensors to prevent DoSAjMetadata builder utilitiesB`Read all tensors in stream orderBmRead the next tensor\xe2\x80\x99s data in stream orderBeRead tensor data with default optionsBmAlignment for tensor data (default: 32 bytes)AeTensor data alignmentAkSize of tensor info sectionBaWhether the data was decompressedAcInvalid tensor dataBgUtilities for working with quantizationBbResult of a stream write operationBhTensor info written, ready for alignmentBhMemory usage information for tensor dataAjOptions for tensor readingAgTypes of tensor storageB`Configuration for tensor writingAmResult of writing tensor dataAeGet alignment trackerCjCalculate the padding needed to align to the specified \xe2\x80\xa6BnCalculate padding needed for default alignmentCbCalculate strides for C-style (row-major) orderingAlWhether to compress metadataBiGet compression ratio (loaded / expected)BiGet the compression ratio compared to F32BcCompression ratio (actual/expected)BfWhether to compute and store checksumsAlWhether to compute checksumsAhDefault alignment to useAjCheck if in tensor sectionBdMaximum metadata size to prevent DoSBbNumber of metadata key-value pairsBcGet total tensor data bytes writtenAkGet total tensor data bytesB`Calculate total tensor data sizeAiTotal size of tensor dataAmTotal size of all tensor data0AlGet tensor types by categoryAkAdd common LLaMA parametersAaWrite tensor dataBkWrite tensor data (must be called in order)CjOperation requires allocation but alloc feature is not \xe2\x80\xa6AeFeature not availableBiSummary of what a GGUFBuilder will createBjMinimum valid GGUF file size (header only)CbQuantization parameters for different tensor typesB`Configuration for stream readingB`Configuration for stream writingAhUnsupported GGUF versionCgGet the theoretical dynamic range for this quantizationBgWhether to load tensor data immediatelyCgCalculate the expected size of the tensor data in bytesCfCheck if a position is aligned to the default boundaryCgCheck if this tensor is compatible with another for \xe2\x80\xa6CaCheck if an alignment value is valid (power of 2)AnGet tensor data section offsetAoOffset where tensor data beginsAmResult of writing tensor infoAhTensor info write resultBkGet total size including loaded tensor dataBbWhether to validate data alignmentAmWhether to validate checksumsBgValidate the integrity of the GGUF fileBbWhether to validate data integrityBhWhether to perform data integrity checksB`Write tensor information sectionAhWrite tensor informationBbSummary of stream reading progressBdGet all supported quantization typesAkGet the average tensor sizeCgCheck if this tensor type is optimized for memory usageAhNumber of loaded tensorsCgGet the shape for matrix multiplication (if applicable)BbGet all non-quantized tensor typesCbCalculate optimal buffer size for reading a tensorBlRead tensor data in chunks for large tensorsBnRead tensor data at a specific offset and sizeBjCheck if a tensor should be read in chunksAcTotal bytes written0AjWrite a complete GGUF fileBbCategories of quantization schemesBcUtility for streaming GGUF creationBnAdd a quantized tensor with raw quantized dataAlAdd a tensor with TensorDataCbCalculate the aligned size using default alignmentCmCalculate the number of blocks needed for a given element \xe2\x80\xa6BdWhether to decompress quantized dataAdLoad all tensor dataBjGet tensor types suitable for a model sizeAkWrite tensor data in chunksBjMaximum supported array length in metadataAoAdd an output projection tensorAlAlign to tensor data sectionAmAlign for tensor data sectionBoCalculate padding needed for specific alignmentBeCheck if two shapes are broadcastableBkLoad only specific tensors by name patternsAhCategory of quantizationBaRead multiple tensors efficientlyBeRead tensor data at a specific offsetBoUpdate tensor offsets after writing tensor infoAdSet tensor alignmentBdWrite a complete GGUF file to streamChDefault alignment requirement for tensor data (32 bytes)BkMaximum supported string length in metadataCgConvenience function to create a buffered stream readerCiCalculate the storage size for a given number of elementsBlGet current alignment info without advancingBnCheck if a quantization type is considered \xe2\x80\xa6AkNumber of quantized tensorsCaRead multiple tensors by seeking to their offsetsCkGet recommended quantization for model size and quality \xe2\x80\xa6BeUnload all tensor data to save memoryCmPerform comprehensive validation including reasonableness \xe2\x80\xa6BbWrite multiple tensors in sequenceAnBuilder for tensor collectionsCiGet the total size of header + metadata + tensor info \xe2\x80\xa6CbGet quantization family (legacy, k-quant, i-quant)BcRecommended buffer size for readingCkConvenience function to create a stream reader from any \xe2\x80\xa6CfCheck if this tensor type supports specific operationsBgMemory requirements for reading tensorsBnConvert to a string representation for displayBhWrite tensor data at a specific positionBkWrite tensor data with custom configurationBhResult of writing a complete GGUF streamCbCalculate the padding needed for default alignmentCfGet the most similar quantization to a target bit rateCfCheck if this shape is compatible for element-wise \xe2\x80\xa6B`Actually loaded tensor data sizeCgValidate that the shape is reasonable for practical useBoWrite tensor data in chunks (for large tensors)CgCheck if the tensor count is reasonable (not too large)AoNumber of non-quantized tensorsChConvenience function to open a GGUF file with custom \xe2\x80\xa6ChCheck if this type is suitable for a given precision \xe2\x80\xa6CaEstimate the quantization error (higher is worse)AoExpected total tensor data sizeCjConvenience function to create a GGUF file with custom \xe2\x80\xa6CiCheck if the metadata count is reasonable (not too large)CaCalculate memory requirements for reading tensorsBdRead tensor data with custom options")